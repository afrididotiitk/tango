!whitespace : ' ' | '\t' | '\n' | '\r' ;
!comment : _lineComment | _blockComment ;
_lineComment : '/' '/' {.} '\n' ;
_blockComment : '/' '*' {. | '*'} '*' '/' ;

/* Production Rules */

_newline      : '\x0A' ;
_ascii_char   : '\x00'-'\x09' | '\x0B'-'\x21' | '\x23'-'\x26' | '\x28'-'\x59' | '\x61'-'\xFF' ;
_ascii_letter : 'a'-'z' | 'A'-'Z' ;
_ascii_digit  : '0'-'9' ;

_letter                : _ascii_letter | '_' ;
_decimal_digit_wo_zero : '1'-'9' ;
_decimal_digit         : '0' | _decimal_digit_wo_zero ;
_octal_digit           : '0' - '7' ;
_hex_digit             : '0' - '9' | 'A' - 'F' | 'a' - 'f' ;

_decimal_lit : _decimal_digit_wo_zero { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_ascii_value_rune   : _ascii_char | '"'  | '`'  | _escaped_char ;
_ascii_value_string : _ascii_char | '\'' | '`'  | _escaped_char ;
_byte_value         : _octal_byte_value | _hex_byte_value ;
_octal_byte_value   : '\\' _octal_digit _octal_digit _octal_digit ;
_hex_byte_value     : '\\' 'x' _hex_digit _hex_digit ;
_escaped_char       : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '"' | '\'' ) ;

_raw_string_lit         : '`' { _ascii_char | '"' | '\'' | _newline } '`' ;
_interpreted_string_lit : '"' { _ascii_value_string | _byte_value } '"' ;

/* Lexical Part */

keyword_break      : 'b' 'r' 'e' 'a' 'k' ;
keyword_default    : 'd' 'e' 'f' 'a' 'u' 'l' 't' ;
keyword_func       : 'f' 'u' 'n' 'c' ;
keyword_interface  : 'i' 'n' 't' 'e' 'r' 'f' 'a' 'c' 'e' ;
keyword_case       : 'c' 'a' 's' 'e' ;
keyword_defer      : 'd' 'e' 'f' 'e' 'r' ;
keyword_map        : 'm' 'a' 'p' ;
keyword_struct     : 's' 't' 'r' 'u' 'c' 't' ;
keyword_else       : 'e' 'l' 's' 'e' ;
keyword_goto       : 'g' 'o' 't' 'o' ;
keyword_package    : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
keyword_switch     : 's' 'w' 'i' 't' 'c' 'h' ;
keyword_const      : 'c' 'o' 'n' 's' 't' ;
keyword_fallthrough: 'f' 'a' 'l' 'l' 't' 'h' 'r' 'o' 'u' 'g' 'h' ;
keyword_if         : 'i' 'f' ;
keyword_range      : 'r' 'a' 'n' 'g' 'e' ;
keyword_type       : 't' 'y' 'p' 'e' ;
keyword_continue   : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;
keyword_for        : 'f' 'o' 'r' ;
keyword_import     : 'i' 'm' 'p' 'o' 'r' 't' ;
keyword_return     : 'r' 'e' 't' 'u' 'r' 'n' ;
keyword_var        : 'v' 'a' 'r' ;

identifier         : _letter { _letter | _ascii_digit } ;

int_lit            : _decimal_lit | _octal_lit | _hex_lit ;
float_lit          : _decimals '.' [ _decimals ] [ _exponent ] | _decimals _exponent | '.' _decimals [ _exponent ] ;
rune_lit           : '\'' ( _ascii_value_rune | _byte_value ) '\'' ;
string_literal     : _raw_string_lit | _interpreted_string_lit ;

binary_op  : '|' '|' | '&' '&' | _rel_op | _add_op | _mul_op ;
_rel_op     : '=' '=' | '!' '=' | '<' | '<' '=' | '>' | '>' '=' ;
_add_op     : '+' | '-' | '|' | '^' ;
_mul_op     : '*' | '/' | '%' | '<' '<' | '>' '>' | '&' | '&' '^' ;
unary_op   : '+' | '-' | '!' | '^' | '*' | '&' ;

inc_dec_op  : '+' '+' | '-' '-' ;

_norm_assign_op : [ _add_op | _mul_op ] '=' ;
_auto_assign_op : ':' '=' ;

assign_op : _norm_assign_op | _auto_assign_op ;

spread_op : '.' '.' '.' ;

left_block_bracket : '{' ;
right_block_bracket: '}' ;
left_paren         : '(' ;
right_paren        : ')' ;
left_sq_paren      : '[' ;
right_sq_paren     : ']' ;
label_op           : ':' ;
stmt_end           : ';' ;
comma              : ',' ;
dot                : '.' ;

/* Syntax Part */

<< import "tango/src/ast" >>

SourceFile     : PackageClause stmt_end ImportDeclList TopLevelDeclList    << ast.AddNode("SourceFile", $0, $1, $2, $3) >>
               ;

PackageClause  : keyword_package PackageName                               << ast.AddNode("PackageClause", $0, $1) >>
               ;
PackageName    : identifier                                                << ast.AddNode("PackageName", $0) >>
               ;


ImportPath     : string_literal                                            << ast.AddNode("ImportPath", $0) >>
               ;
ImportSpec     : ImportPath                                                << ast.AddNode("ImportSpec", $0) >>
               | dot ImportPath                                            << ast.AddNode("ImportSpec", $0, $1) >>
               | PackageName ImportPath                                    << ast.AddNode("ImportSpec", $0, $1) >>
               ;
ImportList     : empty                                                     << ast.AddNode("ImportList") >>
               | ImportList ImportSpec stmt_end                            << ast.AddNode("ImportList", $0, $1, $2) >>
               ;

ImportDecl     : keyword_import ImportSpec                                 << ast.AddNode("ImportDecl", $0, $1) >>
               | keyword_import left_paren ImportList right_paren          << ast.AddNode("ImportDecl", $0, $1, $2, $3) >>
               ;

ImportDeclList : empty                                                     << ast.AddNode("ImportDeclList") >>
               | ImportDeclList ImportDecl stmt_end                        << ast.AddNode("ImportDeclList", $0, $1, $2) >>
               ;

TopLevelDeclList : empty                                                   << ast.AddNode("TopLevelDeclList") >>
                 | TopLevelDeclList TopLevelDecl stmt_end                  << ast.AddNode("TopLevelDeclList", $0, $1, $2) >>
                 ;

TopLevelDecl : Declaration                                                 << ast.AddNode("TopLevelDecl", $0) >>
             | FunctionDecl
             | MethodDecl
             ;

FunctionDecl : keyword_func FunctionName Function
             | keyword_func FunctionName Signature
             ;

FunctionName : identifier
             ;

MethodDecl : keyword_func Receiver MethodName Function
           | keyword_func Receiver MethodName Signature
           ;

Receiver : Parameters
         ;


Declaration : ConstDecl                                                   << ast.AddNode("Declaration", $0) >>
            | TypeDecl
            | VarDecl
            ;

ConstDecl : keyword_const ConstGroup                                      << ast.AddNode("ConstDecl", $0, $1) >>
          ;

ConstGroup : ConstSpec                                                    << ast.AddNode("ConstGroup", $0) >>
           | left_paren ConstSpecList right_paren                         << ast.AddNode("ConstGroup", $0, $1, $2) >>
           ;

ConstSpecList : empty                                                     << ast.AddNode("ConstSpecList") >>
              | ConstSpecList ConstSpec stmt_end                          << ast.AddNode("ConstSpecList", $0, $1, $2) >>
              ;

ConstSpec : IdentifierList Type "=" IdentifierList             << ast.AddNode("ConstSpec", $0, $1, $2, $3) >>
          ;

IdentifierList : identifier                                               << ast.AddNode("IdentifierList", $0) >>
               | IdentifierList comma identifier                          << ast.AddNode("IdentifierList", $0, $1, $2) >>
               ;

TypeDecl  : keyword_type TypeSpecGroup
          ;

TypeSpecGroup : TypeSpec
              | left_paren TypeSpecList right_paren
              ;

TypeSpecList : empty
             | TypeSpecList TypeSpec stmt_end
             ;
TypeSpec     : AliasDecl
             | TypeDef
             ;

AliasDecl    : identifier "=" Type
             ;
TypeDef      : identifier Type
             ;

Type      : TypeName                                                      << ast.AddNode("Type", $0) >>
          | TypeLit                                                       << ast.AddNode("Type", $0) >>
          | left_paren Type right_paren                                   << ast.AddNode("Type", $0, $1, $2) >>
          ;

TypeName  : identifier                                                    << ast.AddNode("TypeName", $0) >>
          | QualifiedIdent                                                << ast.AddNode("TypeName", $0) >>
          ;

TypeLit   : ArrayType                                                     << ast.AddNode("TypeLit", $0) >>
          | StructType                                                    << ast.AddNode("TypeLit", $0) >>  
          | PointerType                                                   << ast.AddNode("TypeLit", $0) >>
          | FunctionType                                                  << ast.AddNode("TypeLit", $0) >>
          | InterfaceType                                                 << ast.AddNode("TypeLit", $0) >>
          | SliceType                                                     << ast.AddNode("TypeLit", $0) >>
          | MapType                                                       << ast.AddNode("TypeLit", $0) >>
          ;

ArrayType   : left_sq_paren ArrayLength right_sq_paren ElementType        << ast.AddNode("ArrayType", $0, $1, $2, $3) >>
            ;

ArrayLength : Expression                                                  << ast.AddNode("ArrayLength", $0) >>
            ;

ElementType : Type                                                        << ast.AddNode("ElementType", $0) >>
            ;

SliceType : left_sq_paren right_sq_paren ElementType                      << ast.AddNode("SliceType", $0, $1, $2) >>
          ;

StructType    : keyword_struct left_block_bracket FieldDeclList right_block_bracket << ast.AddNode("StructType", $0, $1, $2, $3) >>
              ;

FieldDeclList : empty                                                     << ast.AddNode("FieldDeclList") >>
              | FieldDeclList FieldDecl stmt_end                          << ast.AddNode("FieldDeclList", $0, $1, $2) >>
              ;

FieldDecl     : IdentifierList Type                                      << ast.AddNode("FieldDecl", $0, $1) >>
              | EmbeddedField                                            << ast.AddNode("FieldDecl", $0) >>
              ;

EmbeddedField : "*" TypeName                                             << ast.AddNode("EmbeddedField", $0, $1) >>
              | TypeName                                                 << ast.AddNode("EmbeddedField", $0) >>
              ;

PointerType : "*" BaseType                                               << ast.AddNode("PointerType", $0, $1) >>
            ;

BaseType    : Type                                                       << ast.AddNode("BaseType", $0) >>
            ;

FunctionType   : keyword_func Signature                                  << ast.AddNode("FunctionType", $0, $1) >>
               ;

Signature      : Parameters ParametersList Result                        << ast.AddNode("Signature", $0, $1, $2) >>
               | Parameters ParametersList                               << ast.AddNode("Signature", $0, $1) >>
               ;

ParametersList : empty                                                   << ast.AddNode("ParametersList") >>
               | ParametersList Parameters                               << ast.AddNode("ParametersList", $0, $1) >>
               ;

Result         : Type                                                    << ast.AddNode("Result", $0) >>
               ;

Parameters     : left_paren ParameterList comma right_paren              << ast.AddNode("Parameters", $0, $1, $2, $3) >>
               | left_paren ParameterList right_paren                    << ast.AddNode("Parameters", $0, $1, $2) >>
               | left_paren right_paren                                  << ast.AddNode("Parameters", $0, $1) >>
               ;

ParameterList  : ParameterDecl                                           << ast.AddNode("ParameterList", $0) >>
               | ParameterList comma ParameterDecl                       << ast.AddNode("ParameterList", $0, $1, $2) >>
               ;

ParameterDecl  : Type                                                    << ast.AddNode("ParameterDecl", $0) >>
               | spread_op Type                                          << ast.AddNode("ParameterDecl", $0, $1) >>
               | IdentifierList Type                                     << ast.AddNode("ParameterDecl", $0, $1) >>
               | IdentifierList spread_op Type                           << ast.AddNode("ParameterDecl", $0, $1, $2) >>
               ;

InterfaceType      : keyword_interface left_block_bracket MethodSpecList right_block_bracket << ast.AddNode("InterfaceType", $0, $1, $2, $3) >>
                   ;

MethodSpecList : empty                                                   << ast.AddNode("MethodSpecList") >>
               | MethodSpecList MethodSpec stmt_end                      << ast.AddNode("MethodSpecList", $0, $1, $2) >>
               ;

MethodSpec         : MethodName Signature                                << ast.AddNode("MethodSpec", $0, $1) >>
                   | InterfaceTypeName                                   << ast.AddNode("MethodSpec", $0) >>
                   ;

MethodName         : identifier                                          << ast.AddNode("MethodName", $0) >>
                   ;

InterfaceTypeName  : TypeName                                            << ast.AddNode("InterfaceTypeName", $0) >>
                   ;

MapType     : keyword_map left_sq_paren KeyType right_sq_paren ElementType << ast.AddNode("MapType", $0, $1, $2, $3, $4) >>
            ;

KeyType     : Type                                                       << ast.AddNode("KeyType", $0) >>
            ;

QualifiedIdent : PackageName dot identifier                              << ast.AddNode("QualifiedIdent", $0, $1, $2) >>
               ;

VarDecl     : keyword_var VarSpecGroup
            ;

VarSpecGroup : left_paren VarSpecList right_paren
             ;

VarSpecList : empty
            | VarSpecList VarSpec stmt_end
            ;

VarSpec     : IdentifierList ExpressionListGroup
            ;

ExpressionListGroup : Type
                    | Type "=" ExpressionList
                    | "=" ExpressionList
                    ;

Operand     : Literal
            | OperandName
            | MethodExpr
            | left_paren Expression right_paren
            ;

OperandName : identifier
            | QualifiedIdent
            ;

Literal     : BasicLit
            | CompositeLit
            | FunctionLit
            ;

BasicLit    : int_lit
            | float_lit
            | rune_lit
            | string_literal
            ;

CompositeLit : LiteralType LiteralValue
             ;

LiteralType : StructType
            | ArrayType
            | left_sq_paren spread_op right_sq_paren ElementType
            | SliceType
            | MapType
            | TypeName
            ;
LiteralValue : left_block_bracket right_block_bracket
             | left_block_bracket ElementList right_block_bracket
             | left_block_bracket ElementList comma right_block_bracket
             ;

ElementList : KeyedElement
            | ElementList comma KeyedElement
            ;

KeyedElement : Element
             | Key label_op Element
             ;

Key          : FieldName
             | Expression
             | LiteralValue
             ;

FieldName    : identifier
             ;

Element      : Expression
             | LiteralValue
             ;

FunctionLit  : keyword_func Function
             ;

Function     : Signature FunctionBody
             ;

FunctionBody : Block
             ;

Block        : left_block_bracket StatementList right_block_bracket
             ;

StatementList : empty
              | StatementList Statement stmt_end
              ;

Statement    : Declaration
             | LabeledStmt
             | SimpleStmt
             | ReturnStmt
             | BreakStmt
             | ContinueStmt
             | GotoStmt
             | FallthroughStmt
             | Block
             | IfStmt
             | SwitchStmt
             | ForStmt
             | DeferStmt
             ;

LabeledStmt : Label label_op Statement
            ;
Label       : identifier
            ;

SimpleStmt : EmptyStmt
           | ExpressionStmt
           | IncDecStmt
           | Assignment
           | ShortVarDecl
           ;

EmptyStmt : empty
          ;

ExpressionStmt : Expression
               ;

IncDecStmt : Expression inc_dec_op
           ;

Assignment : ExpressionList assign_op ExpressionList
           ;

ShortVarDecl : IdentifierList ":=" ExpressionList
             ;

ReturnStmt : keyword_return
           | keyword_return ExpressionList
           ;

BreakStmt  : keyword_break
           | keyword_break Label
           ;

ContinueStmt : keyword_continue
             | keyword_continue Label
             ;

GotoStmt : keyword_goto Label
         ;

FallthroughStmt : keyword_fallthrough
                ;

IfStmt : keyword_if Expression Block
       | keyword_if SimpleStmt stmt_end Expression Block
       | keyword_if Expression Block keyword_else IfStmtGrp
       | keyword_if SimpleStmt stmt_end Expression Block keyword_else IfStmtGrp
       ;

IfStmtGrp : IfStmt
          | Block
          ;

SwitchStmt : ExprSwitchStmt
           ;

ExprSwitchStmt : keyword_switch left_block_bracket ExprCaseClauseList right_block_bracket
               | keyword_switch SimpleStmt stmt_end left_block_bracket ExprCaseClauseList right_block_bracket
               | keyword_switch Expression left_block_bracket ExprCaseClauseList right_block_bracket
               | keyword_switch SimpleStmt stmt_end Expression left_block_bracket ExprCaseClauseList right_block_bracket
               ;

ExprCaseClauseList : empty
                   | ExprCaseClauseList ExprCaseClause
                   ;

ExprCaseClause : ExprSwitchCase label_op StatementList
               ;

ExprSwitchCase : keyword_case ExpressionList
               | keyword_default
               ;

ForStmt : keyword_for Block
        | keyword_for ConditionGrp Block
        ;

ConditionGrp : Condition
             | ForClause
             | RangeClause
             ;

Condition : Expression
          ;

ForClause : stmt_end stmt_end
          | InitStmt stmt_end stmt_end
          | stmt_end Condition stmt_end
          | stmt_end stmt_end PostStmt
          | InitStmt stmt_end Condition stmt_end
          | stmt_end Condition stmt_end PostStmt
          | InitStmt stmt_end stmt_end PostStmt
          | InitStmt stmt_end Condition stmt_end PostStmt
          ;

InitStmt : SimpleStmt
         ;

PostStmt : SimpleStmt
         ;

RangeClause : keyword_range Expression
            | ExpressionList "=" keyword_range Expression
            | IdentifierList ":=" keyword_range Expression
            ;

DeferStmt : keyword_defer Expression
          ;

ExpressionList : Expression
               | ExpressionList comma Expression
               ;

Expression : UnaryExpr
           | Expression binary_op Expression
           ;

UnaryExpr : PrimaryExpr
          | unary_op UnaryExpr
          ;

PrimaryExpr : Operand
            | Conversion
            | ForCompExpr
            | PrimaryExpr Selector
            | PrimaryExpr Index
            | PrimaryExpr Slice
            | PrimaryExpr TypeAssertion
            | PrimaryExpr Arguments
            ;

Conversion : Type left_paren Expression right_paren
           | Type left_paren Expression comma right_paren
           ;

MethodExpr : ReceiverType dot MethodName
           ;

ReceiverType : TypeName
             | left_paren "*" TypeName right_paren
             | left_paren ReceiverType right_paren
             ;

ForCompExpr : left_sq_paren Expression "|" RangeClause right_sq_paren
            ;

Selector : dot identifier
         ;

Index : left_sq_paren Expression right_sq_paren
      ;

Slice : left_sq_paren label_op right_sq_paren
      | left_sq_paren Expression label_op right_sq_paren
      | left_sq_paren label_op Expression right_sq_paren
      | left_sq_paren Expression label_op Expression right_sq_paren
      | left_sq_paren label_op Expression label_op Expression right_sq_paren
      | left_sq_paren Expression label_op Expression label_op Expression right_sq_paren
      ;

TypeAssertion : dot left_paren Type right_paren
              ;

Arguments : left_paren right_paren
          | left_paren ArgInnerGroup right_paren
          ;

ArgInnerGroup : ExpressionList
              | ExpressionList spread_op
              | ExpressionList comma
              | ExpressionList spread_op comma
              | Type
              | Type spread_op
              | Type comma
              | Type spread_op comma
              | Type comma ExpressionList
              | Type comma ExpressionList spread_op
              | Type comma ExpressionList comma
              | Type comma ExpressionList spread_op comma
              ;
