!whitespace : ' ' | '\t' | '\n' | '\r' ;
!comment : _lineComment | _blockComment ;
_lineComment : '/' '/' {.} '\n' ;
_blockComment : '/' '*' {. | '*'} '*' '/' ;

/* Production Rules */

_newline      : '\x0A' ;
_ascii_char   : '\x00'-'\x09' | '\x0B'-'\x21' | '\x23'-'\x26' | '\x28'-'\x59' | '\x61'-'\xFF' ;
_ascii_letter : 'a'-'z' | 'A'-'Z' ;
_ascii_digit  : '0'-'9' ;

_letter                : _ascii_letter | '_' ;
_decimal_digit_wo_zero : '1'-'9' ;
_decimal_digit         : '0' | _decimal_digit_wo_zero ;
_octal_digit           : '0' - '7' ;
_hex_digit             : '0' - '9' | 'A' - 'F' | 'a' - 'f' ;

_decimal_lit : _decimal_digit_wo_zero { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_ascii_value_rune   : _ascii_char | '"'  | '`'  | _escaped_char ;
_ascii_value_string : _ascii_char | '\'' | '`'  | _escaped_char ;
_byte_value         : _octal_byte_value | _hex_byte_value ;
_octal_byte_value   : '\\' _octal_digit _octal_digit _octal_digit ;
_hex_byte_value     : '\\' 'x' _hex_digit _hex_digit ;
_escaped_char       : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '"' | '\'' ) ;

_raw_string_lit         : '`' { _ascii_char | '"' | '\'' | _newline } '`' ;
_interpreted_string_lit : '"' { _ascii_value_string | _byte_value } '"' ;

/* Lexical Part */

keyword_break      : 'b' 'r' 'e' 'a' 'k' ;
keyword_default    : 'd' 'e' 'f' 'a' 'u' 'l' 't' ;
keyword_func       : 'f' 'u' 'n' 'c' ;
keyword_interface  : 'i' 'n' 't' 'e' 'r' 'f' 'a' 'c' 'e' ;
keyword_case       : 'c' 'a' 's' 'e' ;
keyword_defer      : 'd' 'e' 'f' 'e' 'r' ;
keyword_map        : 'm' 'a' 'p' ;
keyword_struct     : 's' 't' 'r' 'u' 'c' 't' ;
keyword_else       : 'e' 'l' 's' 'e' ;
keyword_goto       : 'g' 'o' 't' 'o' ;
keyword_package    : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
keyword_switch     : 's' 'w' 'i' 't' 'c' 'h' ;
keyword_const      : 'c' 'o' 'n' 's' 't' ;
keyword_fallthrough: 'f' 'a' 'l' 'l' 't' 'h' 'r' 'o' 'u' 'g' 'h' ;
keyword_if         : 'i' 'f' ;
keyword_range      : 'r' 'a' 'n' 'g' 'e' ;
keyword_type       : 't' 'y' 'p' 'e' ;
keyword_continue   : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;
keyword_for        : 'f' 'o' 'r' ;
keyword_import     : 'i' 'm' 'p' 'o' 'r' 't' ;
keyword_return     : 'r' 'e' 't' 'u' 'r' 'n' ;
keyword_var        : 'v' 'a' 'r' ;

identifier         : _letter { _letter | _ascii_digit } ;

int_lit            : _decimal_lit | _octal_lit | _hex_lit ;
float_lit          : _decimals '.' [ _decimals ] [ _exponent ] | _decimals _exponent | '.' _decimals [ _exponent ] ;
rune_lit           : '\'' ( _ascii_value_rune | _byte_value ) '\'' ;
string_literal     : _raw_string_lit | _interpreted_string_lit ;

rel_op     : '=' '=' | '!' '=' | '<' '=' | '>' '=' | '>' | '<' ;
mul_op     : '/' | '%' | '<' '<' | '>' '>' | '&' | '&' '^' ;
unary_op   : '!' | '&' ;

inc_dec_op  : '+' '+' | '-' '-' ;

norm_assign_op  : '=' ;
mod_assign_op   : '|' '=' | '+' '=' | '-' '=' | '^' '='
                | '*' '=' | '/' '=' | '%' '=' | '<' '<' '=' | '>' '>' '=' | '&' '=' | '&' '^' '=';
auto_assign_op  : ':' '=' ;

spread_op : '.' '.' '.' ;

left_block_bracket : '{' ;
right_block_bracket: '}' ;
left_paren         : '(' ;
right_paren        : ')' ;
left_sq_paren      : '[' ;
right_sq_paren     : ']' ;
label_op           : ':' ;
stmt_end           : ';' ;
comma              : ',' ;
dot                : '.' ;
star               : '*' ;
plus               : '+' ;
minus              : '-' ;
xor                : '^' ;
simple_pipe        : '|' ;
andand             : '&' '&' ;
oror               : '|' '|' ;
left_angle         : '<' '<' '<' ;
right_angle        : '>' '>' '>' ;
left_banana        : '[' '(' ;
right_banana       : ')' ']' ;
left_tuple         : '(' '|' ;
right_tuple        : '|' ')' ;
pipe               : '|' '|' '|';

/* Syntax Part */

<< import "tango/src/ast" >>

SourceFile    : PackageClause Imports DeclList  << ast.NewSourceFile($2) >>
              ;

PackageClause : keyword_package identifier stmt_end
              ;

Imports    : empty
           | Imports Import stmt_end
           ;

Import     : keyword_import ImportStmt
           | keyword_import left_paren ImportStmtList OSemi right_paren
           | keyword_import left_paren right_paren
           ;

ImportStmt : ImportHere string_literal
           ;

ImportStmtList : ImportStmt
               | ImportStmtList stmt_end ImportStmt
               ;

ImportHere : empty
           | identifier
           | dot
           ;

/* Declarations */
Declaration : CommonDecl << $0, nil >>
            | FuncDecl	<< $0, nil >>
            | NonDeclStmt	<< $0, nil >>
//            | error
            ;

CommonDecl : keyword_const ConstDecl	<< $1, nil >>
           | keyword_const left_paren ConstDecl OSemi right_paren	<< $2, nil >>
           | keyword_const left_paren ConstDecl stmt_end ConstDeclList OSemi right_paren	<< ast.MultConstDecl($2, $4) >>
           | keyword_const left_paren right_paren	<< &ast.AddrCode{}, nil >>
           | keyword_var VarDecl	<< $1, nil >>
           | keyword_var left_paren VarDeclList OSemi right_paren	<< ast.MergeCodeList($2) >>
           | keyword_var left_paren right_paren	<< &ast.AddrCode{}, nil >>
           | keyword_type TypeDecl	<< nil, ast.ErrUnsupported >>
           | keyword_type left_paren TypeDeclList OSemi right_paren	<< nil, ast.ErrUnsupported >>
           | keyword_type left_paren right_paren	<< nil, ast.ErrUnsupported >>
           ; 

VarDecl   : DeclNameList NType	<< ast.Decl($0, $1, nil, false) >>
          | DeclNameList NType norm_assign_op ExprList	<< ast.Decl($0, $1, $3, false) >>
          | DeclNameList norm_assign_op ExprList	<< nil, ast.ErrUnsupported >>
          ;

ConstDecl : DeclNameList NType norm_assign_op ExprList	<< ast.Decl($0, $1, $3, true) >>
          | DeclNameList norm_assign_op ExprList	<< nil, ast.ErrUnsupported >>
          ;

ConstDecl1 : ConstDecl	<< $0, nil >>
           | DeclNameList NType	<< nil, ast.ErrUnsupported >>
           | DeclNameList	<< nil, ast.ErrUnsupported >>
           ;

TypeDeclName : identifier	<< nil, ast.ErrUnsupported >>
             ;

TypeDecl : TypeDeclName NType	<< nil, ast.ErrUnsupported >>
         ;

// TODO: Think about addressable left hand side
SimpleStmt : Expr	<< $0, nil >>
           | Expr mod_assign_op Expr	<< ast.ModAssignment($0, $1, $2) >>
           | ExprList norm_assign_op ExprList	<< ast.Assignments($0, $2) >>
           | ExprList auto_assign_op ExprList	<< nil, ast.ErrUnsupported >>
           | Expr inc_dec_op	<< ast.IncDec($0, $1) >>
           ;

Case : keyword_case ExprOrTypeList label_op	<< ast.AddNode("Case", $0, $1, $2) >>
     | keyword_case ExprOrTypeList norm_assign_op Expr label_op	<< ast.AddNode("Case", $0, $1, $2, $3, $4) >>
     | keyword_case ExprOrTypeList auto_assign_op Expr label_op	<< ast.AddNode("Case", $0, $1, $2, $3, $4) >>
     | keyword_default label_op	<< ast.AddNode("Case", $0, $1) >>
     ;

CompoundStmt : left_block_bracket StmtList right_block_bracket	<< ast.MergeCodeList($1) >>
             ;

CaseBlock : Case StmtList	<< ast.AddNode("CaseBlock", $0, $1) >>
          ;

CaseBlockList : empty	<< ast.AddNode("CaseBlockList") >>
              | CaseBlockList CaseBlock	<< ast.AddNode("CaseBlockList", $0, $1) >>
              ;

LoopBody : left_block_bracket StmtList right_block_bracket	<< ast.MergeCodeList($1) >>
         ;

RangeStmt : ExprList norm_assign_op keyword_range Expr	<< ast.AddNode("RangeStmt", $0, $1, $2, $3) >>
          | ExprList auto_assign_op keyword_range Expr	<< ast.AddNode("RangeStmt", $0, $1, $2, $3) >>
          | keyword_range Expr	<< ast.AddNode("RangeStmt", $0, $1) >>
          ;

ForHeader : OSimpleStmt stmt_end OExpr stmt_end OSimpleStmt << ast.EvalForHeader($0, $2, $4) >>
          | OExpr     	                                    << ast.EvalForHeader(&ast.AddrCode{}, $0, &ast.AddrCode{}) >>
          | RangeStmt	                                      << nil, ast.ErrUnsupported >>
          ;

ForBody : ForHeader LoopBody	                        << ast.EvalForBody($0, $1) >>
        ;

ForStmt : keyword_for ForBody	                        << $1, nil >>
        ;

IfHeader : Expr       	                              << $0, nil >>
         | OSimpleStmt stmt_end Expr       	          << ast.EvalIfHeader($0, $2) >>
         ;

IfStmt : keyword_if IfHeader LoopBody ElseIfList Else	<< ast.EvalIf($1, $2, $3, $4) >>
       ;

ElseIf : keyword_else keyword_if IfHeader LoopBody	  << ast.EvalElseIf($2, $3) >>
       ;

ElseIfList : empty                                    << ast.NewIfElseList(nil) >>
           | ElseIfList ElseIf                        << ast.AddToIfElseList($0, $1) >>
           ;

Else : empty	                                        << &ast.AddrCode{}, nil >>
     | keyword_else CompoundStmt	                    << $1, nil >>
     ;

NType : FuncType	<< ast.AddNode("NType", $0) >>
      |	OtherType	<< ast.AddNode("NType", $0) >>
      |	PtrType	<< ast.AddNode("NType", $0) >>
      |	DotName	<< ast.AddNode("NType", $0) >>
      |	left_paren NType right_paren	<< ast.AddNode("NType", $0, $1, $2) >>
      ;

NonExprType : FuncType	<< ast.AddNode("NonExprType", $0) >>
            | OtherType	<< ast.AddNode("NonExprType", $0) >>
            | star NonExprType	<< ast.AddNode("NonExprType", $0, $1) >>
            ;

OtherType : left_sq_paren OExpr right_sq_paren NType	<< ast.AddNode("OtherType", $0, $1, $2, $3) >>
          | keyword_map left_sq_paren NType right_sq_paren NType	<< ast.AddNode("OtherType", $0, $1, $2, $3, $4) >>
          | StructType	<< ast.AddNode("OtherType", $0) >>
          | InterfaceType	<< ast.AddNode("OtherType", $0) >>
          ;

StructType : keyword_struct left_block_bracket StructDeclList OSemi right_block_bracket	<< ast.AddNode("StructType", $0, $1, $2, $3, $4) >>
           | keyword_struct left_block_bracket right_block_bracket	<< ast.AddNode("StructType", $0, $1, $2) >>
           ;

InterfaceType : keyword_interface left_block_bracket InterfaceDeclList OSemi right_block_bracket	<< ast.AddNode("InterfaceType", $0, $1, $2, $3, $4) >>
              | keyword_interface left_block_bracket right_block_bracket	<< ast.AddNode("InterfaceType", $0, $1, $2) >>
              ;

/* Function Stuff - All together to show how crappy it is */
FuncDecl : keyword_func FuncDecl_ FuncBody	                                      << ast.FuncDecl($1, $2) >>
         ;

FuncDecl_ : identifier ArgList FuncRes                                            << ast.FuncSign($0, $1, $2, nil) >>
          | left_tuple OArgTypeListOComma right_tuple identifier ArgList FuncRes  << ast.FuncSign($3, $4, $5, $1) >>
          ;

FuncType : keyword_func ArgList FuncRes	<< ast.AddNode("FuncType", $0, $1, $2) >>
         ;

ArgList : left_paren OArgTypeListOComma right_paren	<< ast.AddNode("ArgList", $0, $1, $2) >>
        | ArgList left_paren OArgTypeListOComma right_paren	<< ast.AddNode("ArgList", $0, $1, $2, $3) >>
        ;

FuncBody : empty	<< &ast.AddrCode{}, nil >>
         | left_block_bracket StmtList right_block_bracket	<< ast.MergeCodeList($1) >>
         ;

FuncRes : empty	<< ast.AddNode("FuncRes") >>
        | FuncRetType	<< ast.AddNode("FuncRes", $0) >>
        | left_tuple OArgTypeListOComma right_tuple	<< ast.AddNode("FuncRes", $0, $1, $2) >>
        ;

StructDeclList : StructDecl	<< ast.AddNode("StructDeclList", $0) >>
               | StructDeclList stmt_end StructDecl	<< ast.AddNode("StructDeclList", $0, $1, $2) >>
               ;

InterfaceDeclList : InterfaceDecl	<< ast.AddNode("InterfaceDeclList", $0) >>
                  | InterfaceDeclList stmt_end InterfaceDecl	<< ast.AddNode("InterfaceDeclList", $0, $1, $2) >>
                  ;

StructDecl : NewNameList NType OLiteral	<< ast.AddNode("StructDecl", $0, $1, $2) >>
           | Embed OLiteral	<< ast.AddNode("StructDecl", $0, $1) >>
           | left_paren Embed right_paren OLiteral	<< ast.AddNode("StructDecl", $0, $1, $2, $3) >>
           | star Embed OLiteral	<< ast.AddNode("StructDecl", $0, $1, $2) >>
           | left_paren star Embed right_paren OLiteral	<< ast.AddNode("StructDecl", $0, $1, $2, $3, $4) >>
           | star left_paren Embed right_paren OLiteral	<< ast.AddNode("StructDecl", $0, $1, $2, $3, $4) >>
           ;

InterfaceDecl : NewName InDecl	<< ast.AddNode("InterfaceDecl", $0, $1) >>
              | identifier	<< ast.AddNode("InterfaceDecl", $0) >>
              | left_paren identifier right_paren	<< ast.AddNode("InterfaceDecl", $0, $1, $2) >>
              ;

InDecl : left_paren OArgTypeListOComma right_paren FuncRes	<< ast.AddNode("InDecl", $0, $1, $2, $3) >>
       ;

LabelName : NewName	<< ast.AddNode("LabelName", $0) >>
          ;
NewName : identifier	<< ast.AddNode("NewName", $0) >>
        ;

PtrType : star NType	<< ast.AddNode("PtrType", $0, $1) >>
        ;

FuncRetType : FuncType	<< ast.AddNode("FuncRetType", $0) >>
            | OtherType	<< ast.AddNode("FuncRetType", $0) >>
            | PtrType	<< ast.AddNode("FuncRetType", $0) >>
            | DotName	<< ast.AddNode("FuncRetType", $0) >>
            ;

DotName : Name	<< ast.AddNode("DotName", $0) >>
        | Name dot identifier	<< ast.AddNode("DotName", $0, $1, $2) >>
        ;

OComma : empty
       | comma
       ;

OSemi : empty
      | stmt_end
      ;

OSimpleStmt : empty	      << &ast.AddrCode{}, nil >>
            | SimpleStmt	<< $0, nil >>
            ;

ONewName : empty	<< ast.AddNode("ONewName") >>
         | NewName	<< ast.AddNode("ONewName", $0) >>
         ;

OExpr : empty	<< nil, nil >>
      | Expr	<< $0, nil >>
      ;

OExprList : empty	<< ast.NewList(nil) >>
          | ExprList	<< $0, nil >>
          ;

FuncLiteralDecl : FuncType	<< ast.AddNode("FuncLiteralDecl", $0) >>
                ;

FuncLiteral : FuncLiteralDecl left_block_bracket StmtList right_block_bracket	<< ast.AddNode("FuncLiteral", $0, $1, $2, $3) >>
//            | FuncLiteralDecl error
            ;

ExprList : Expr	<< ast.NewList($0) >>
         | ExprList comma Expr	<< ast.AddToList($0, $2) >>
         ;

ExprOrTypeList : ExprOrType	<< ast.AddNode("ExprOrTypeList", $0) >>
               | ExprOrTypeList comma ExprOrType	<< ast.AddNode("ExprOrTypeList", $0, $1, $2) >>
               ;


OLiteral : empty	<< nil, nil >>
         | Literal	<< $0, nil >>
         ;

Literal : int_lit	<< ast.IntLit($0) >>
        | float_lit	<< nil, ast.ErrUnsupported >>
        | rune_lit	<< nil, ast.ErrUnsupported >>
        | string_literal	<< nil, ast.ErrUnsupported >>
        ;

Embed : identifier	<< ast.AddNode("Embed", $0) >>
      ;

DeclList : empty	<< ast.NewList(nil) >>
         | DeclList Declaration stmt_end	<< ast.AddToList($0, $1) >>
         ;

VarDeclList : VarDecl	<< ast.NewList($0) >>
            | VarDeclList stmt_end VarDecl	<< ast.AddToList($0, $2) >>
            ;

ConstDeclList : ConstDecl1	<< ast.NewList($0) >>
              | ConstDeclList stmt_end ConstDecl1	<< ast.AddToList($0, $2) >>
              ;

TypeDeclList : TypeDecl	<< ast.AddNode("TypeDeclList", $0) >>
             | TypeDeclList stmt_end TypeDecl	<< ast.AddNode("TypeDeclList", $0, $1, $2) >>
             ;

DeclNameList : DeclName	<< ast.NewList($0) >>
             | DeclNameList comma DeclName	<< ast.AddToList($0, $2) >>
             ;

StmtList : Stmt	<< ast.NewList($0) >>
         | StmtList stmt_end Stmt	<< ast.AddToList($0, $2) >>
         ;

NewNameList : NewName	<< ast.AddNode("NewNameList", $0) >>
            | NewNameList comma NewName	<< ast.AddNode("NewNameList", $0, $1, $2) >>
            ;

KeyvalList : Keyval	<< ast.AddNode("KeyvalList", $0) >>
           | BareCompLitExpr	<< ast.AddNode("KeyvalList", $0) >>
           | KeyvalList comma Keyval	<< ast.AddNode("KeyvalList", $0, $1, $2) >>
           | KeyvalList comma BareCompLitExpr	<< ast.AddNode("KeyvalList", $0, $1, $2) >>
           ;

BracedKeyvalList : empty	<< ast.AddNode("BracedKeyvalList") >>
                 | KeyvalList OComma	<< ast.AddNode("BracedKeyvalList", $0, $1) >>
                 ;

DeclName : identifier	<< ast.Identifier($0) >>
         ;

Name : identifier	<< ast.Identifier($0) >>
     ;

ArgType : NameOrType	<< ast.AddNode("ArgType", $0) >>
        | identifier NameOrType	<< ast.AddNode("ArgType", $0, $1) >>
        | identifier DotDotDot	<< ast.AddNode("ArgType", $0, $1) >>
        | DotDotDot	<< ast.AddNode("ArgType", $0) >>
        ;

ArgTypeList : ArgType	<< ast.AddNode("ArgTypeList", $0) >>
            | ArgTypeList comma ArgType	<< ast.AddNode("ArgTypeList", $0, $1, $2) >>
            ;

OArgTypeListOComma : empty	<< ast.AddNode("OArgTypeListOComma") >>
                   | ArgTypeList OComma	<< ast.AddNode("OArgTypeListOComma", $0, $1) >>
                   ;

/* Statement */
Stmt : empty	      << &ast.AddrCode{}, nil >>
     | CompoundStmt	<< $0, nil >>
     | CommonDecl	  << $0, nil >>
     | NonDeclStmt	<< $0, nil >>
//     | error
     ;

NonDeclStmt : SimpleStmt	              << $0, nil >>
            | ForStmt	                  << $0, nil >>
            | SwitchStmt	              << ast.AddNode("NonDeclStmt", $0) >>
            | IfStmt	                  << $0, nil >>
            | LabelName label_op Stmt	  << ast.AddNode("NonDeclStmt", $0, $1, $2) >>
            | keyword_fallthrough	      << ast.AddNode("NonDeclStmt", $0) >>
            | keyword_break ONewName	  << ast.AddNode("NonDeclStmt", $0, $1) >>
            | keyword_continue ONewName	<< ast.AddNode("NonDeclStmt", $0, $1) >>
            | keyword_defer PseudoCall  << ast.AddNode("NonDeclStmt", $0, $1) >>
            | keyword_goto NewName      << ast.AddNode("NonDeclStmt", $0, $1) >>
            | keyword_return OExprList  << ast.AddNode("NonDeclStmt", $0, $1) >>
            ;

DotDotDot : spread_op	<< ast.AddNode("DotDotDot", $0) >>
          | spread_op NType	<< ast.AddNode("DotDotDot", $0, $1) >>
          ;

PExpr : PExprNoParen	<< $0, nil >>
      | left_paren ExprOrType right_paren	<< ast.AddNode("PExpr", $0, $1, $2) >>
      ;

PExprNoParen : Literal                                                                << $0, nil >>
             | Name                                                                   << $0, nil >>
             | PExpr dot identifier	                                                  << nil, ast.ErrUnsupported >>
             | PExpr dot left_paren ExprOrType right_paren	                          << nil, ast.ErrUnsupported >>
             | PExpr dot left_paren keyword_type right_paren	                        << nil, ast.ErrUnsupported >>
             | PExpr left_sq_paren Expr right_sq_paren	                              << nil, ast.ErrUnsupported >>
             | PExpr left_sq_paren OExpr label_op OExpr right_sq_paren	              << nil, ast.ErrUnsupported >>
             | PExpr left_sq_paren OExpr label_op OExpr label_op OExpr right_sq_paren	<< nil, ast.ErrUnsupported >>
             | PseudoCall                                                             << nil, ast.ErrUnsupported >>
             | ConvType left_angle Expr OComma right_angle                            << nil, ast.ErrUnsupported >>
             | CompType left_banana BracedKeyvalList right_banana                     << nil, ast.ErrUnsupported >>
             | PExpr left_banana BracedKeyvalList right_banana                        << nil, ast.ErrUnsupported >>
             | FuncLiteral                                                            << ast.AddNode("PExprNoParen", $0) >>
             | ForCompExpr                                                            << ast.AddNode("PExprNoParen", $0) >>
             ;

ConvType : FuncType	<< ast.AddNode("ConvType", $0) >>
         | OtherType	<< ast.AddNode("ConvType", $0) >>
         ;

CompType : OtherType	<< ast.AddNode("CompType", $0) >>
         ;

// Signifies beginning of a composite expression
StartCompLit : empty	<< ast.AddNode("StartCompLit") >>
             ;

Keyval : Expr label_op CompLitExpr	<< ast.AddNode("Keyval", $0, $1, $2) >>
       ;

BareCompLitExpr : Expr	<< ast.AddNode("BareCompLitExpr", $0) >>
                | left_banana BracedKeyvalList right_banana	<< ast.AddNode("BareCompLitExpr", $0, $1, $2) >>
                ;

CompLitExpr : Expr	<< ast.AddNode("CompLitExpr", $0) >>
            | left_banana BracedKeyvalList right_banana	<< ast.AddNode("CompLitExpr", $0, $1, $2) >>
            ;

ExprOrType : Expr	<< ast.AddNode("ExprOrType", $0) >>
           | NonExprType	<< ast.AddNode("ExprOrType", $0) >>
           ;

NameOrType : NType	<< ast.AddNode("NameOrType", $0) >>
           ;

SwitchStmt : keyword_switch IfHeader left_block_bracket CaseBlockList right_block_bracket	<< ast.AddNode("SwitchStmt", $0, $1, $2, $3, $4) >>
           ;
           
/* Expressions */
// My fix for binary_op SR Conflict might be wrong. Double Check Please!!!

Prec5Expr_ : UExpr	                            << $0, nil >>
           | Prec5Expr_ mul_op UExpr	          << ast.BinaryOp($0, $1, $2) >>
           | Prec5Expr_ star UExpr	            << ast.BinaryOp($0, $1, $2) >>
           ;

Prec4Expr_ : Prec5Expr_	                        << $0, nil >>
           | Prec4Expr_ plus Prec5Expr_	        << ast.BinaryOp($0, $1, $2) >>
           | Prec4Expr_ minus Prec5Expr_	      << ast.BinaryOp($0, $1, $2) >>
           | Prec4Expr_ xor Prec5Expr_	        << ast.BinaryOp($0, $1, $2) >>
           | Prec4Expr_ simple_pipe Prec5Expr_	<< ast.BinaryOp($0, $1, $2) >>
           ;

Prec3Expr_ : Prec4Expr_	                        << $0, nil >>
           | Prec3Expr_ rel_op Prec4Expr_	      << ast.RelOp($0, $1, $2) >>
           ;

Prec2Expr_ : Prec3Expr_	                        << $0, nil >>
           | Prec2Expr_ andand Prec3Expr_	      << ast.AndOp($0, $2) >>
           ;

Expr       : Prec2Expr_	                        << $0, nil >>
           | Expr oror Prec2Expr_	              << ast.OrOp($0, $2) >>
           ;

UExpr : PExpr	                                  << $0, nil >>
      | unary_op UExpr	                        << ast.UnaryOp($0, $1) >>
      | star UExpr	                            << ast.UnaryOp($0, $1) >>
      | plus UExpr	                            << $1, nil >>
      | minus UExpr	                            << ast.UnaryOp($0, $1) >>
      | xor UExpr	                              << ast.UnaryOp($0, $1) >>
      ;

ForCompExpr : left_sq_paren Expr pipe RangeStmt right_sq_paren	<< ast.AddNode("ForCompExpr", $0, $1, $2, $3, $4) >>
            ;

/* Call-Like Statements that can be preceded by 'defer' */
PseudoCall : PExpr left_paren right_paren	                                << ast.AddNode("PseudoCall", $0, $1, $2) >>
           | PExpr left_paren ExprOrTypeList OComma right_paren	          << ast.AddNode("PseudoCall", $0, $1, $2, $3, $4) >>
           | PExpr left_paren ExprOrTypeList spread_op OComma right_paren	<< ast.AddNode("PseudoCall", $0, $1, $2, $3, $4, $5) >>
           ;

