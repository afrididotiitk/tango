<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>

</head>

<body>

<h1>tango</h1>

<p>The Abominably Naive Go Compiler</p>

<h2>Features</h2>

<p>Apart from the usual golang imperative features
(except goroutines and chans), we support the following
extra features:</p>

<h3>Currying</h3>

<p>```
func myCurry(a int, d int)(b int)(c int) int {
     if (d % 2 == 0) {
         return a + b + c;
     } else {
         return a;
     }
}</p>

<p>x1 = myCurry(4, 2)
x2 = myCurry(4, 2)(5)
x3 = myCurry(4, 1)(5)(6)</p>

<p>// Type of x1:
func(int)(int) int</p>

<p>// Type of x2:
func(int) int</p>

<p>// Type of x3:
int</p>

<p>// Type of myCurry
func(int)(int)(int) int
```</p>

<h3>For Comprehensions</h3>

<p><code>
xs := []int{1, 2, 3}
doublexs := [x * 2 | _, x := range xs]
</code></p>

<h2>Intermediate Code Representation (IR)</h2>

<p>Our IR code is the list of instructions where each instruction is represented as structure</p>

<p><code>
struct {
   type IRType; // Enum values for Type are: {BOP, UOP, CBR, JMP, ASN, KEY}
   op IROp;
   arg1 IRArg;
   arg2 IRArg;
   dst IRArg;
   target IRTarget;
}
</code></p>

<h3>Binary Operations (BOP)</h3>

<p>For binary operations (type = BOP), <code>arg1</code> and <code>arg2</code> are arguments for the operation in the same order and <code>dst</code> is the target variable where the result is stored after applying <code>op</code>.</p>

<p><code>
dst =  arg1 op arg2
</code></p>

<p><code>op</code> can have following values with obvious meanings</p>

<p><code>
+, -, *, /, %, &lt;&lt;, &gt;&gt;, &amp;&amp;, ||, &amp;, |, &lt;, &lt;=, &gt;, &gt;=, ==, !=, ^, take (dst = arg1[arg2]), put (arg1[arg2] = dst)
</code></p>

<p><code>arg1</code> and <code>arg2</code> can be either a variable or a literal. Literals should start with <code>$</code> (eg. <code>$2</code> means literal 2). Hexadecimals starts with <code>0x</code>.</p>

<p><em>Convention</em>: Temporary variables should start with <code>r</code> (r1, r2, etc)</p>

<h3>Unary Operations (UOP)</h3>

<p>Unary operations are applied as</p>

<p><code>
dst = op arg1
</code></p>

<p>Here <code>op</code> can have following values</p>

<p><code>
neg, !, inc, dec, not, val (Value at address), addr (address of)
</code></p>

<h3>Assignment Operation (ASN)</h3>

<p>Assignment is fairly simple</p>

<p><code>
dst = arg1
</code></p>

<h3>Labels</h3>

<p>Instructions can be labelled (with labels being strings) to be referred as target in branch instructions as follows</p>

<p><code>
label: dst = arg1 op arg2
</code></p>

<h3>Branch Operations (JMP and CBR)</h3>

<p>Branch operations can be conditional or unconditional.</p>

<p>Unconditional branches are just a simple call to JMP</p>

<p><code>
JMP target
</code></p>

<p>For conditional branches, following instructions are provided</p>

<p><code>
BREQ arg1 arg2 target  // Branch to target if arg1 == arg2
BRNEQ arg1 arg2 target
BRLT arg1 arg2 target
BRLTE arg1 arg2 target
BRGT arg1 arg2 target
BRGTE arg1 arg2 target
</code></p>

<h3>Procedure Call (KEY)</h3>

<p><code>
PARAM arg1   // pass arg1 as function argument
CALL target  // calls the function at target
RET          // return to the return address
HALT         // halts the program
PRINT a      // Prints a
SCAN  a      // Scan into a
</code></p>

</body>
</html>
